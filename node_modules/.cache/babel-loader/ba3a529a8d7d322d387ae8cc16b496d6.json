{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = sequentialQuantile;\n\nvar _index = require(\"../../../lib-vendor/d3-array/src/index.js\");\n\nvar _continuous = require(\"./continuous.js\");\n\nvar _init = require(\"./init.js\");\n\nfunction sequentialQuantile() {\n  var domain = [],\n      interpolator = _continuous.identity;\n\n  function scale(x) {\n    if (x != null && !isNaN(x = +x)) return interpolator(((0, _index.bisect)(domain, x, 1) - 1) / (domain.length - 1));\n  }\n\n  scale.domain = function (_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n\n    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);\n\n    domain.sort(_index.ascending);\n    return scale;\n  };\n\n  scale.interpolator = function (_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.range = function () {\n    return domain.map((d, i) => interpolator(i / (domain.length - 1)));\n  };\n\n  scale.quantiles = function (n) {\n    return Array.from({\n      length: n + 1\n    }, (_, i) => (0, _index.quantile)(domain, i / n));\n  };\n\n  scale.copy = function () {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n\n  return _init.initInterpolator.apply(scale, arguments);\n}","map":{"version":3,"sources":["/Users/nonijoysar/Desktop/react-expense-tracker/node_modules/victory-vendor/lib-vendor/d3-scale/src/sequentialQuantile.js"],"names":["Object","defineProperty","exports","value","default","sequentialQuantile","_index","require","_continuous","_init","domain","interpolator","identity","scale","x","isNaN","bisect","length","_","arguments","slice","d","push","sort","ascending","range","map","i","quantiles","n","Array","from","quantile","copy","initInterpolator","apply"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,kBAAlB;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,2CAAD,CAApB;;AAEA,IAAIC,WAAW,GAAGD,OAAO,CAAC,iBAAD,CAAzB;;AAEA,IAAIE,KAAK,GAAGF,OAAO,CAAC,WAAD,CAAnB;;AAEA,SAASF,kBAAT,GAA8B;AAC5B,MAAIK,MAAM,GAAG,EAAb;AAAA,MACIC,YAAY,GAAGH,WAAW,CAACI,QAD/B;;AAGA,WAASC,KAAT,CAAeC,CAAf,EAAkB;AAChB,QAAIA,CAAC,IAAI,IAAL,IAAa,CAACC,KAAK,CAACD,CAAC,GAAG,CAACA,CAAN,CAAvB,EAAiC,OAAOH,YAAY,CAAC,CAAC,CAAC,GAAGL,MAAM,CAACU,MAAX,EAAmBN,MAAnB,EAA2BI,CAA3B,EAA8B,CAA9B,IAAmC,CAApC,KAA0CJ,MAAM,CAACO,MAAP,GAAgB,CAA1D,CAAD,CAAnB;AAClC;;AAEDJ,EAAAA,KAAK,CAACH,MAAN,GAAe,UAAUQ,CAAV,EAAa;AAC1B,QAAI,CAACC,SAAS,CAACF,MAAf,EAAuB,OAAOP,MAAM,CAACU,KAAP,EAAP;AACvBV,IAAAA,MAAM,GAAG,EAAT;;AAEA,SAAK,IAAIW,CAAT,IAAcH,CAAd,EAAiB,IAAIG,CAAC,IAAI,IAAL,IAAa,CAACN,KAAK,CAACM,CAAC,GAAG,CAACA,CAAN,CAAvB,EAAiCX,MAAM,CAACY,IAAP,CAAYD,CAAZ;;AAElDX,IAAAA,MAAM,CAACa,IAAP,CAAYjB,MAAM,CAACkB,SAAnB;AACA,WAAOX,KAAP;AACD,GARD;;AAUAA,EAAAA,KAAK,CAACF,YAAN,GAAqB,UAAUO,CAAV,EAAa;AAChC,WAAOC,SAAS,CAACF,MAAV,IAAoBN,YAAY,GAAGO,CAAf,EAAkBL,KAAtC,IAA+CF,YAAtD;AACD,GAFD;;AAIAE,EAAAA,KAAK,CAACY,KAAN,GAAc,YAAY;AACxB,WAAOf,MAAM,CAACgB,GAAP,CAAW,CAACL,CAAD,EAAIM,CAAJ,KAAUhB,YAAY,CAACgB,CAAC,IAAIjB,MAAM,CAACO,MAAP,GAAgB,CAApB,CAAF,CAAjC,CAAP;AACD,GAFD;;AAIAJ,EAAAA,KAAK,CAACe,SAAN,GAAkB,UAAUC,CAAV,EAAa;AAC7B,WAAOC,KAAK,CAACC,IAAN,CAAW;AAChBd,MAAAA,MAAM,EAAEY,CAAC,GAAG;AADI,KAAX,EAEJ,CAACX,CAAD,EAAIS,CAAJ,KAAU,CAAC,GAAGrB,MAAM,CAAC0B,QAAX,EAAqBtB,MAArB,EAA6BiB,CAAC,GAAGE,CAAjC,CAFN,CAAP;AAGD,GAJD;;AAMAhB,EAAAA,KAAK,CAACoB,IAAN,GAAa,YAAY;AACvB,WAAO5B,kBAAkB,CAACM,YAAD,CAAlB,CAAiCD,MAAjC,CAAwCA,MAAxC,CAAP;AACD,GAFD;;AAIA,SAAOD,KAAK,CAACyB,gBAAN,CAAuBC,KAAvB,CAA6BtB,KAA7B,EAAoCM,SAApC,CAAP;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = sequentialQuantile;\n\nvar _index = require(\"../../../lib-vendor/d3-array/src/index.js\");\n\nvar _continuous = require(\"./continuous.js\");\n\nvar _init = require(\"./init.js\");\n\nfunction sequentialQuantile() {\n  var domain = [],\n      interpolator = _continuous.identity;\n\n  function scale(x) {\n    if (x != null && !isNaN(x = +x)) return interpolator(((0, _index.bisect)(domain, x, 1) - 1) / (domain.length - 1));\n  }\n\n  scale.domain = function (_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n\n    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);\n\n    domain.sort(_index.ascending);\n    return scale;\n  };\n\n  scale.interpolator = function (_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.range = function () {\n    return domain.map((d, i) => interpolator(i / (domain.length - 1)));\n  };\n\n  scale.quantiles = function (n) {\n    return Array.from({\n      length: n + 1\n    }, (_, i) => (0, _index.quantile)(domain, i / n));\n  };\n\n  scale.copy = function () {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n\n  return _init.initInterpolator.apply(scale, arguments);\n}"]},"metadata":{},"sourceType":"script"}